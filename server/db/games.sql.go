// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: games.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const clearGames = `-- name: ClearGames :exec
DELETE FROM games
`

func (q *Queries) ClearGames(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearGames)
	return err
}

const getApocalypse = `-- name: GetApocalypse :one
SELECT val FROM apocalypses
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetApocalypse(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getApocalypse)
	var val string
	err := row.Scan(&val)
	return val, err
}

const getPlace = `-- name: GetPlace :one
SELECT val FROM places
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetPlace(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getPlace)
	var val string
	err := row.Scan(&val)
	return val, err
}

const getResources = `-- name: GetResources :many
SELECT val FROM resources
ORDER BY RANDOM()
LIMIT $1
`

func (q *Queries) GetResources(ctx context.Context, limit int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getResources, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var val string
		if err := rows.Scan(&val); err != nil {
			return nil, err
		}
		items = append(items, val)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRooms = `-- name: GetRooms :many
SELECT val FROM rooms
ORDER BY RANDOM()
LIMIT $1
`

func (q *Queries) GetRooms(ctx context.Context, limit int32) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getRooms, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var val string
		if err := rows.Scan(&val); err != nil {
			return nil, err
		}
		items = append(items, val)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const multiplyFood = `-- name: MultiplyFood :one
UPDATE games
SET food = food * 2
WHERE id = $1
RETURNING id, apocalypse, size, time, food, place, rooms, resources
`

func (q *Queries) MultiplyFood(ctx context.Context, id uuid.UUID) (Game, error) {
	row := q.db.QueryRowContext(ctx, multiplyFood, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Apocalypse,
		&i.Size,
		&i.Time,
		&i.Food,
		&i.Place,
		&i.Rooms,
		&i.Resources,
	)
	return i, err
}

const newApocalypse = `-- name: NewApocalypse :one
UPDATE games
SET apocalypse = $2
WHERE id = $1
RETURNING id, apocalypse, size, time, food, place, rooms, resources
`

type NewApocalypseParams struct {
	ID         uuid.UUID
	Apocalypse sql.NullString
}

func (q *Queries) NewApocalypse(ctx context.Context, arg NewApocalypseParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, newApocalypse, arg.ID, arg.Apocalypse)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Apocalypse,
		&i.Size,
		&i.Time,
		&i.Food,
		&i.Place,
		&i.Rooms,
		&i.Resources,
	)
	return i, err
}

const newBunker = `-- name: NewBunker :one
UPDATE games
SET size = $2, time = $3, food = $4, place = $5, rooms = $6, resources = $7
WHERE id = $1
RETURNING id, apocalypse, size, time, food, place, rooms, resources
`

type NewBunkerParams struct {
	ID        uuid.UUID
	Size      sql.NullInt32
	Time      sql.NullInt32
	Food      sql.NullInt32
	Place     sql.NullString
	Rooms     sql.NullString
	Resources sql.NullString
}

func (q *Queries) NewBunker(ctx context.Context, arg NewBunkerParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, newBunker,
		arg.ID,
		arg.Size,
		arg.Time,
		arg.Food,
		arg.Place,
		arg.Rooms,
		arg.Resources,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Apocalypse,
		&i.Size,
		&i.Time,
		&i.Food,
		&i.Place,
		&i.Rooms,
		&i.Resources,
	)
	return i, err
}

const setFoodEqualToTime = `-- name: SetFoodEqualToTime :one
UPDATE games
SET food = time
WHERE id = $1
RETURNING id, apocalypse, size, time, food, place, rooms, resources
`

func (q *Queries) SetFoodEqualToTime(ctx context.Context, id uuid.UUID) (Game, error) {
	row := q.db.QueryRowContext(ctx, setFoodEqualToTime, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Apocalypse,
		&i.Size,
		&i.Time,
		&i.Food,
		&i.Place,
		&i.Rooms,
		&i.Resources,
	)
	return i, err
}

const startGame = `-- name: StartGame :one
INSERT INTO games (id, apocalypse, size, time, food, place, rooms, resources)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, apocalypse, size, time, food, place, rooms, resources
`

type StartGameParams struct {
	ID         uuid.UUID
	Apocalypse sql.NullString
	Size       sql.NullInt32
	Time       sql.NullInt32
	Food       sql.NullInt32
	Place      sql.NullString
	Rooms      sql.NullString
	Resources  sql.NullString
}

func (q *Queries) StartGame(ctx context.Context, arg StartGameParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, startGame,
		arg.ID,
		arg.Apocalypse,
		arg.Size,
		arg.Time,
		arg.Food,
		arg.Place,
		arg.Rooms,
		arg.Resources,
	)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.Apocalypse,
		&i.Size,
		&i.Time,
		&i.Food,
		&i.Place,
		&i.Rooms,
		&i.Resources,
	)
	return i, err
}
